</button>
            </div>

            <div class="progress-container" id="progressContainer">
                <div class="progress-bar">
                    <div class="progress-fill" id="progressFill">0%</div>
                </div>
                <div class="progress-text" id="progressText">Initializing...</div>
            </div>
        </div>

        <div id="results"></div>

        <div class="footer">
            <p>Built for Peter | Score 4 = DEPLOY | Score 3 = WATCH (Stealth) | Score 2 = HOLD | Score 0-1 = EXIT</p>
            <p style="margin-top: 0.5rem;">Data provided by Twelve Data API</p>
        </div>
    </div>

    <script>
        // API key management
        function getApiKey() {
            return localStorage.getItem('twelveDataApiKey') || '';
        }
        
        function saveApiKey() {
            const apiKeyInput = document.getElementById('apiKeyInput');
            const apiKey = apiKeyInput.value.trim();
            
            if (!apiKey) {
                alert('Please enter an API key');
                return;
            }
            
            localStorage.setItem('twelveDataApiKey', apiKey);
            updateApiKeyStatus();
            alert('API key saved successfully! It will be used for all future scans.');
        }
        
        function clearApiKey() {
            if (confirm('Are you sure you want to remove your saved API key?')) {
                localStorage.removeItem('twelveDataApiKey');
                document.getElementById('apiKeyInput').value = '';
                updateApiKeyStatus();
            }
        }
        
        function updateApiKeyStatus() {
            const apiKey = getApiKey();
            const statusEl = document.getElementById('apiKeyStatus');
            
            if (apiKey) {
                const masked = '‚Ä¢'.repeat(Math.min(apiKey.length, 20));
                statusEl.innerHTML = `‚úÖ API Key saved: <span style="color: var(--accent-green); font-family: monospace;">${masked}</span> <span style="color: var(--text-secondary);">(${apiKey.length} characters)</span>`;
                statusEl.style.color = 'var(--accent-green)';
            } else {
                statusEl.innerHTML = '‚ö†Ô∏è No API key saved. Please enter and save your Twelve Data API key.';
                statusEl.style.color = 'var(--accent-yellow)';
            }
        }
        
        // Auto mode variables
        let autoMode = false;
        let autoPaused = false;
        let autoCountdownInterval = null;
        
        // Toggle between manual and auto mode
        function toggleMode() {
            autoMode = !autoMode;
            const toggle = document.getElementById('modeToggle');
            const label = document.getElementById('modeLabel');
            const autoStatus = document.getElementById('autoStatus');
            
            if (autoMode) {
                toggle.style.background = 'var(--accent-green)';
                toggle.querySelector('.toggle-slider').style.transform = 'translateX(30px)';
                label.textContent = 'AUTO';
                label.style.color = 'var(--accent-green)';
                autoStatus.style.display = 'block';
            } else {
                toggle.style.background = 'var(--border)';
                toggle.querySelector('.toggle-slider').style.transform = 'translateX(0)';
                label.textContent = 'MANUAL';
                label.style.color = 'var(--text-secondary)';
                autoStatus.style.display = 'none';
            }
        }
        
        // Pause auto mode
        function pauseAuto() {
            autoPaused = true;
            document.getElementById('pauseButton').style.display = 'none';
            if (autoCountdownInterval) {
                clearInterval(autoCountdownInterval);
                autoCountdownInterval = null;
            }
        }
        
        // Auto countdown between batches
        function startAutoCountdown(seconds, callback) {
            const displayEl = document.getElementById('autoCountdown');
            displayEl.style.display = 'block';
            displayEl.textContent = seconds;
            
            let remaining = seconds;
            
            autoCountdownInterval = setInterval(() => {
                if (autoPaused) {
                    clearInterval(autoCountdownInterval);
                    displayEl.style.display = 'none';
                    return;
                }
                
                remaining--;
                displayEl.textContent = remaining;
                
                if (remaining === 0) {
                    clearInterval(autoCountdownInterval);
                    displayEl.style.display = 'none';
                    callback();
                }
            }, 1000);
        }
        
        // Load saved API key on page load
        window.addEventListener('DOMContentLoaded', () => {
            const savedKey = getApiKey();
            if (savedKey) {
                document.getElementById('apiKeyInput').value = savedKey;
            }
            updateApiKeyStatus();
        });
        
        // Batch processing state
        let batchState = {
            allTickers: [],
            currentBatch: 0,
            batchSize: 4,
            results: [],
            regimeMode: null,
            spyData: null,
            vooData: null,
            isProcessing: false
        };

        // Timer state
        let countdownInterval = null;
        let nextAvailableTime = Date.now();
        
        // Asset configuration
        let assetTypes = {};

        // Parse asset types from input
        function parseAssetTypes() {
            const input = document.getElementById('assetTypes').value;
            assetTypes = {};
            
            input.split(',').forEach(item => {
                const [ticker, type] = item.trim().split(':');
                if (ticker && type) {
                    assetTypes[ticker.toUpperCase()] = type.toUpperCase();
                }
            });
        }

        // Stealth Watch Tracking
        function getStealthHistory() {
            const history = localStorage.getItem('stealthHistory');
            return history ? JSON.parse(history) : {};
        }

        function saveStealthHistory(history) {
            localStorage.setItem('stealthHistory', JSON.stringify(history));
        }

        function updateStealthTracking(results) {
            const history = getStealthHistory();
            const today = new Date().toDateString();
            
            // Initialize today's tracking
            if (!history[today]) {
                history[today] = {};
            }
            
            // Update tracking for each ticker
            results.forEach(result => {
                const { ticker, score } = result;
                
                if (score === 3) {
                    // Track 3/4 tickers
                    if (!history[today][ticker]) {
                        // New 3/4 - check if it was 3/4 yesterday
                        const yesterday = new Date(Date.now() - 86400000).toDateString();
                        const yesterdayData = history[yesterday]?.[ticker];
                        
                        history[today][ticker] = {
                            score: 3,
                            consecutiveDays: yesterdayData?.score === 3 ? yesterdayData.consecutiveDays + 1 : 1,
                            firstSeen: yesterdayData?.firstSeen || today
                        };
                    }
                } else {
                    // Not 3/4 - reset tracking
                    delete history[today][ticker];
                }
            });
            
            // Clean up old history (keep last 30 days)
            const thirtyDaysAgo = Date.now() - (30 * 86400000);
            Object.keys(history).forEach(date => {
                if (new Date(date).getTime() < thirtyDaysAgo) {
                    delete history[date];
                }
            });
            
            saveStealthHistory(history);
            return history[today];
        }

        function getStealthWatchList(results) {
            const today = new Date().toDateString();
            const history = getStealthHistory();
            const todayTracking = history[today] || {};
            
            return results
                .filter(r => {
                    const tracking = todayTracking[r.ticker];
                    if (!tracking) return false;
                    
                    // Criteria for Stealth Watch
                    return (
                        r.score === 3 &&  // Must be 3/4
                        tracking.consecutiveDays >= 5 &&  // 5+ consecutive days
                        r.breakdown.dma20 &&  // Above 20-DMA
                        r.breakdown.dma50 &&  // Above 50-DMA
                        r.perf.change5Day <= 10  // Not extended >10%
                    );
                })
                .map(r => ({
                    ...r,
                    consecutiveDays: todayTracking[r.ticker].consecutiveDays,
                    firstSeen: todayTracking[r.ticker].firstSeen
                }));
        }

        function getMissingSignal(breakdown, mode) {
            if (!breakdown.rsi) return 'RSI';
            if (mode === 'MODE A' && !breakdown.dma20) return '20-DMA';
            if (!breakdown.dma50) return '50-DMA';
            if (!breakdown.volume) return 'Volume';
            if (!breakdown.rs) return 'RS vs SPY';
            return 'Unknown';
        }

        // Countdown timer
        function startCountdownTimer(seconds) {
            nextAvailableTime = Date.now() + (seconds * 1000);
            
            const timerEl = document.getElementById('countdownTimer');
            const displayEl = document.getElementById('timerDisplay');
            const messageEl = document.getElementById('timerMessage');
            
            timerEl.classList.add('active', 'waiting');
            timerEl.classList.remove('ready');
            
            if (countdownInterval) clearInterval(countdownInterval);
            
            countdownInterval = setInterval(() => {
                const remaining = Math.max(0, Math.ceil((nextAvailableTime - Date.now()) / 1000));
                
                if (remaining > 0) {
                    const minutes = Math.floor(remaining / 60);
                    const seconds = remaining % 60;
                    displayEl.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
                    displayEl.classList.add('waiting');
                    messageEl.textContent = 'Waiting for rate limit cooldown...';
                } else {
                    displayEl.textContent = '‚úÖ Ready';
                    displayEl.classList.remove('waiting');
                    messageEl.textContent = 'Safe to run next analysis';
                    timerEl.classList.remove('waiting');
                    timerEl.classList.add('ready');
                    clearInterval(countdownInterval);
                }
            }, 100);
        }

        // Update progress bar
        function updateProgress(current, total, message) {
            const progressContainer = document.getElementById('progressContainer');
            const progressFill = document.getElementById('progressFill');
            const progressText = document.getElementById('progressText');
            
            const percentage = Math.round((current / total) * 100);
            
            progressContainer.classList.add('active');
            progressFill.style.width = percentage + '%';
            progressFill.textContent = percentage + '%';
            progressText.textContent = message;
        }

        // Show batch pause notice
        function showPauseNotice(batchNum, totalBatches, remainingTickers) {
            const pauseNotice = document.getElementById('pauseNotice');
            const pauseCountdown = document.getElementById('pauseCountdown');
            const continueButton = document.getElementById('continueButton');
            const autoCountdown = document.getElementById('autoCountdown');
            
            pauseNotice.classList.add('active');
            continueButton.disabled = true;
            
            let countdown = 60;
            pauseCountdown.textContent = countdown;
            continueButton.textContent = `‚è≥ Continue Next Batch (${countdown}s)`;
            
            if (autoMode && !autoPaused) {
                // Auto mode: start 60-second countdown and auto-continue
                document.getElementById('pauseButton').style.display = 'block';
                continueButton.style.display = 'none';
                
                startAutoCountdown(60, () => {
                    pauseNotice.classList.remove('active');
                    document.getElementById('pauseButton').style.display = 'none';
                    autoPaused = false;
                    processBatch();
                });
            } else {
                // Manual mode or paused: show button and manual countdown
                continueButton.style.display = 'block';
                autoCountdown.style.display = 'none';
                
                const countdownTimer = setInterval(() => {
                    countdown--;
                    pauseCountdown.textContent = countdown;
                    continueButton.textContent = `‚è≥ Continue Next Batch (${countdown}s)`;
                    
                    if (countdown <= 0) {
                        clearInterval(countdownTimer);
                        continueButton.disabled = false;
                        continueButton.textContent = `‚úÖ Continue with ${remainingTickers} tickers`;
                        pauseCountdown.textContent = '0';
                    }
                }, 1000);
            }
        }
        
        async function continueAnalysis() {
            autoPaused = false;
            document.getElementById('pauseNotice').classList.remove('active');
            document.getElementById('continueButton').disabled = true;
            await processBatch();
        }
        
        // Finish analysis
        function finishAnalysis() {
            document.getElementById('progressContainer').classList.remove('active');
            document.getElementById('batchInfo').classList.remove('active');
            document.getElementById('pauseNotice').classList.remove('active');
            document.getElementById('pauseButton').style.display = 'none';
            batchState.isProcessing = false;
            autoPaused = false;
            
            // Start cooldown timer (2 minutes)
            startCountdownTimer(120);
        }

        function calculateRSI(prices, period = 14) {
            if (prices.length < period + 1) return 50;
            
            const changes = [];
            for (let i = 1; i < prices.length; i++) {
                changes.push(prices[i] - prices[i - 1]);
            }
            
            const gains = changes.slice(-period).filter(x => x > 0);
            const losses = changes.slice(-period).filter(x => x < 0).map(Math.abs);
            
            const avgGain = gains.length ? gains.reduce((a, b) => a + b, 0) / period : 0;
            const avgLoss = losses.length ? losses.reduce((a, b) => a + b, 0) / period : 0;
            
            if (avgLoss === 0) return 100;
            
            const rs = avgGain / avgLoss;
            return 100 - (100 / (1 + rs));
        }

        function calculateMA(prices, period) {
            if (prices.length < period) return prices[prices.length - 1];
            const slice = prices.slice(-period);
            return slice.reduce((a, b) => a + b, 0) / period;
        }

        function calculateVolRatio(volumes, period = 20) {
            if (volumes.length < period + 1) return 1.0;
            
            const now = new Date();
            const hour = now.getHours();
            const day = now.getDay();
            
            const isMarketHours = (day >= 1 && day <= 5) && (hour >= 9 && hour < 16);
            
            let currentVol;
            let volumesForAvg;
            
            if (isMarketHours && volumes.length >= 2) {
                currentVol = volumes[volumes.length - 2];
                volumesForAvg = volumes.slice(volumes.length - period - 2, volumes.length - 2);
            } else {
                currentVol = volumes[volumes.length - 1];
                volumesForAvg = volumes.slice(volumes.length - period - 1, volumes.length - 1);
            }
            
            const avgVol = volumesForAvg.reduce((sum, v) => sum + v, 0) / volumesForAvg.length;
            
            if (!currentVol || currentVol === 0 || !avgVol || avgVol === 0) {
                return 1.0;
            }
            
            return currentVol / avgVol;
        }

        // Calculate recent performance metrics
        function calculatePerformanceMetrics(prices) {
            const metrics = {
                change1Day: 0,
                change5Day: 0,
                change10Day: 0
            };

            if (prices.length < 2) return metrics;

            const currentPrice = prices[prices.length - 1];

            // 1-day change
            if (prices.length >= 2) {
                const price1DayAgo = prices[prices.length - 2];
                metrics.change1Day = ((currentPrice / price1DayAgo) - 1) * 100;
            }

            // 5-day change
            if (prices.length >= 6) {
                const price5DaysAgo = prices[prices.length - 6];
                metrics.change5Day = ((currentPrice / price5DaysAgo) - 1) * 100;
            }

            // 10-day change
            if (prices.length >= 11) {
                const price10DaysAgo = prices[prices.length - 11];
                metrics.change10Day = ((currentPrice / price10DaysAgo) - 1) * 100;
            }

            return metrics;
        }

        // Generate warnings based on performance
        function generatePerformanceWarnings(perf, rsi, score) {
            const warnings = [];
            let severity = 'normal';
            let positionSize = '1%';

            if (perf.change5Day > 10) {
                warnings.push({
                    text: `üî• Up ${perf.change5Day.toFixed(1)}% in 5 days - parabolic move, very high risk`,
                    level: 'danger'
                });
                severity = 'danger';
                positionSize = '0.25-0.5%';
            } else if (perf.change5Day > 7) {
                warnings.push({
                    text: `üìà Up ${perf.change5Day.toFixed(1)}% in 5 days - extended, consider smaller size`,
                    level: 'warning'
                });
                severity = 'warning';
                positionSize = '0.5-0.75%';
            } else if (perf.change5Day > 5) {
                warnings.push({
                    text: `üìä Up ${perf.change5Day.toFixed(1)}% in 5 days - some extension, watch for pullback`,
                    level: 'warning'
                });
                if (severity === 'normal') severity = 'warning';
                positionSize = '0.75%';
            }

            if (rsi > 75 && perf.change5Day > 5) {
                warnings.push({
                    text: `‚ö†Ô∏è Overbought (RSI ${rsi.toFixed(0)}) + extended move - high reversal risk`,
                    level: 'danger'
                });
                severity = 'danger';
                positionSize = '0.25-0.5%';
            } else if (rsi > 70 && perf.change5Day > 7) {
                warnings.push({
                    text: `‚ö†Ô∏è Elevated RSI + strong move - wait for pullback to 20-DMA`,
                    level: 'warning'
                });
                if (severity !== 'danger') severity = 'warning';
            }

            if (perf.change5Day < 3 && perf.change5Day > -2 && score >= 3) {
                warnings.push({
                    text: `‚úÖ Fresh setup - minimal extension, good entry timing`,
                    level: 'normal'
                });
            }

            if (perf.change10Day > 15 && perf.change5Day > 5) {
                warnings.push({
                    text: `üöÄ Strong 10-day trend (+${perf.change10Day.toFixed(1)}%) - momentum established but late entry`,
                    level: 'warning'
                });
            }

            return { warnings, severity, positionSize };
        }

        // Fetch stock data from Twelve Data API
        async function fetchStockData(ticker) {
            const apiKey = getApiKey();
            
            if (!apiKey) {
                alert('Please save your API key before running analysis');
                throw new Error('No API key available');
            }
            
            const url = `https://api.twelvedata.com/time_series?symbol=${ticker}&interval=1day&outputsize=180&apikey=${apiKey}`;
            
            try {
                const response = await fetch(url);
                const data = await response.json();
                
                if (data.status === 'error' || !data.values) {
                    console.error(`Error for ${ticker}:`, data.message || 'Invalid data');
                    throw new Error(data.message || 'Invalid data');
                }
                
                const values = data.values.reverse();
                const prices = values.map(v => parseFloat(v.close));
                const volumes = values.map(v => parseFloat(v.volume));
                
                return { prices, volumes };
            } catch (error) {
                console.error(`Error fetching ${ticker}:`, error);
                return null;
            }
        }

        // Determine regime mode
        function getRegimeMode(vooPrices) {
            if (vooPrices.length < 200) return 'RISK';
            
            const currentPrice = vooPrices[vooPrices.length - 1];
            const dma200 = calculateMA(vooPrices, 200);
            
            return currentPrice > dma200 ? 'RISK' : 'DEFENSIVE';
        }

        // Determine active mode for ticker
        function getActiveMode(ticker, regimeMode) {
            const assetType = assetTypes[ticker] || 'RISK';
            
            if (regimeMode === 'DEFENSIVE' || assetType === 'DEFENSIVE') {
                return 'MODE B';
            }
            return 'MODE A';
        }

        // Calculate regime-aware score
        function calculateScore(ticker, data, spyData, mode) {
            let score = 0;
            const breakdown = {
                rsi: false,
                dma20: false,
                dma50: false,
                volume: false,
                rs: false,
                rsiValue: 0,
                dma20Value: 0,
                dma50Value: 0,
                volumeRatio: 0
            };
            
            const prices = data.prices;
            const volumes = data.volumes;
            
            const currentPrice = prices[prices.length - 1];
            const prevPrice = prices[prices.length - 2] || currentPrice;
            const dma20 = calculateMA(prices, 20);
            const dma50 = calculateMA(prices, 50);
            const rsi = calculateRSI(prices);
            const prevRSI = calculateRSI(prices.slice(0, -1));
            const volRatio = calculateVolRatio(volumes);
            
            breakdown.rsiValue = rsi;
            breakdown.dma20Value = dma20;
            breakdown.dma50Value = dma50;
            breakdown.volumeRatio = volRatio;
            
            const perf = calculatePerformanceMetrics(prices);
            
            let vsspy = 0;
            if (spyData && prices.length >= 20 && spyData.prices.length >= 20) {
                const tickerReturn = ((currentPrice / prices[prices.length - 20]) - 1) * 100;
                const spyReturn = ((spyData.prices[spyData.prices.length - 1] / spyData.prices[spyData.prices.length - 20]) - 1) * 100;
                vsspy = tickerReturn - spyReturn;
            }
            
            if (mode === 'MODE A') {
                if (rsi >= 55) {
                    score++;
                    breakdown.rsi = true;
                }
                
                if (currentPrice > dma20 && currentPrice > dma50) {
                    score++;
                    breakdown.dma20 = true;
                    breakdown.dma50 = true;
                } else if (currentPrice > dma50) {
                    breakdown.dma50 = true;
                }
                
                if (volRatio >= 1.2) {
                    score++;
                    breakdown.volume = true;
                }
                
                if (vsspy > 0) {
                    score++;
                    breakdown.rs = true;
                }
            } else {
                const rsiRising = rsi > prevRSI;
                
                if (rsi >= 45 && rsiRising) {
                    score++;
                    breakdown.rsi = true;
                }
                
                if (currentPrice > dma20) {
                    score++;
                    breakdown.dma20 = true;
                }
                
                if (volRatio >= 1.0) {
                    score++;
                    breakdown.volume = true;
                }
                
                if (vsspy > 0) {
                    score++;
                    breakdown.rs = true;
                }
            }
            
            const perfAnalysis = generatePerformanceWarnings(perf, rsi, score);
            
            return { score, breakdown, perf, perfAnalysis };
        }

        function getSignal(score, perf) {
            // FIXED: Only score 4/4 gets deploy recommendations
            if (score === 4) {
                if (perf.change5Day > 10) {
                    return { 
                        text: 'üî¥ TOO LATE', 
                        subtext: 'Parabolic move - very high risk',
                        class: 'exit',
                        size: '0.25% max'
                    };
                } else if (perf.change5Day > 5) {
                    return { 
                        text: 'üü° DEPLOY SMALL', 
                        subtext: 'Extended - reduced size or wait for pullback',
                        class: 'watch',
                        size: '0.5-0.75%'
                    };
                } else {
                    return { 
                        text: 'üü¢ DEPLOY NOW', 
                        subtext: 'Fresh setup - good timing',
                        class: 'deploy',
                        size: '1%'
                    };
                }
            }
            
            // Score 3/4 always goes to WATCH (will show in Stealth Watch if meets criteria)
            if (score === 3) {
                return { 
                    text: '‚ö†Ô∏è WATCH', 
                    subtext: 'Score 3/4 - Track in Stealth Watch',
                    class: 'watch',
                    size: '0%'
                };
            }
            
            if (score === 2) {
                return { 
                    text: '‚ö†Ô∏è WATCH', 
                    subtext: 'Don\'t enter new - hold if owned',
                    class: 'watch',
                    size: '0%'
                };
            }
            
            if (score === 1) {
                return { 
                    text: 'üî¥ HOLD', 
                    subtext: 'Weakening - prepare to exit',
                    class: 'hold',
                    size: '0%'
                };
            }
            
            return { 
                text: 'üî¥ EXIT', 
                subtext: 'Trend broken - sell',
                class: 'exit',
                size: '0%'
            };
        }

        function renderResults(results, regimeMode) {
            const resultsDiv = document.getElementById('results');
            
            // Update stealth tracking
            updateStealthTracking(results);
            const stealthList = getStealthWatchList(results);
            
            // Render Stealth Watch section
            let stealthHTML = '';
            if (stealthList.length > 0) {
                const stealthCards = stealthList.map(s => {
                    const missingSignal = getMissingSignal(s.breakdown, s.mode);
                    const positionSize = s.consecutiveDays >= 10 ? '1%' : '0.5-0.75%';
                    
                    return `
                        <div class="stealth-card">
                            <div class="stealth-header">
                                <div class="stealth-ticker">${s.ticker}</div>
                                <div class="stealth-score">${s.score}/4</div>
                            </div>
                            <div class="stealth-days">üìÖ ${s.consecutiveDays} days at 3/4</div>
                            <div class="stealth-metrics">
                                <div class="stealth-metric">
                                    <div class="stealth-metric-label">5-Day</div>
                                    <div class="stealth-metric-value ${s.perf.change5d >= 0 ? 'positive' : 'negative'}">
                                        ${s.perf.change5d >= 0 ? '+' : ''}${s.perf.change5d.toFixed(2)}%
                                    </div>
                                </div>
                                <div class="stealth-metric">
                                    <div class="stealth-metric-label">Vol Ratio</div>
                                    <div class="stealth-metric-value">${s.breakdown.volumeRatio?.toFixed(2)}x</div>
                                </div>
                            </div>
                            <div class="stealth-missing">
                                ‚ö†Ô∏è Missing: ${missingSignal}
                            </div>
                            <div class="stealth-action">
                                üü° PROBE ${positionSize}
                            </div>
                        </div>
                    `;
                }).join('');
                
                stealthHTML = `
                    <div class="stealth-watch">
                        <h2>üîç STEALTH WATCH - Building Momentum (Deploy 3/4)</h2>
                        <div class="subtitle">
                            These tickers have been at 3/4 for 5+ days while holding above DMAs. 
                            Consider small probe positions (0.5-1%) ahead of volume breakout.
                        </div>
                        <div class="stealth-grid">
                            ${stealthCards}
                        </div>
                    </div>
                `;
            }
            
            let cardsHTML = '<div class="ticker-grid">';
            
            results.forEach(result => {
                const signal = getSignal(result.score, result.perf);
                const modeClass = result.mode === 'MODE A' ? 'mode-a' : 'mode-b';
                const scoreClass = `score-${result.score}`;
                
                const perfClass = result.perfAnalysis.severity === 'danger' ? 'danger' : 
                                 result.perfAnalysis.severity === 'warning' ? 'warning' : '';
                
                const perfHTML = `
                    <div class="performance-metrics ${perfClass}">
                        <div class="perf-title">üìä Recent Performance</div>
                        <div class="perf-stats">
                            <div class="perf-stat">
                                <span class="perf-label">1-Day</span>
                                <span class="perf-value ${result.perf.change1Day >= 0 ? 'positive' : 'negative'}">
                                    ${result.perf.change1Day >= 0 ? '+' : ''}${result.perf.change1Day.toFixed(2)}%
                                </span>
                            </div>
                            <div class="perf-stat">
                                <span class="perf-label">5-Day</span>
                                <span class="perf-value ${result.perf.change5Day >= 0 ? 'positive' : 'negative'}">
                                    ${result.perf.change5Day >= 0 ? '+' : ''}${result.perf.change5Day.toFixed(2)}%
                                </span>
                            </div>
                            <div class="perf-stat">
                                <span class="perf-label">10-Day</span>
                                <span class="perf-value ${result.perf.change10Day >= 0 ? 'positive' : 'negative'}">
                                    ${result.perf.change10Day >= 0 ? '+' : ''}${result.perf.change10Day.toFixed(2)}%
                                </span>
                            </div>
                        </div>
                    </div>
                `;
                
                // Build breakdown list
                const breakdownHTML = [];
                if (result.mode === 'MODE A') {
                    breakdownHTML.push(`<li class="${result.breakdown.rsi ? 'pass' : 'fail'}">${result.breakdown.rsi ? '‚úÖ' : '‚ùå'} RSI ${result.breakdown.rsiValue.toFixed(1)} (‚â•55)</li>`);
                    breakdownHTML.push(`<li class="${result.breakdown.dma20 && result.breakdown.dma50 ? 'pass' : 'fail'}">${result.breakdown.dma20 && result.breakdown.dma50 ? '‚úÖ' : '‚ùå'} Above both DMAs</li>`);
                    breakdownHTML.push(`<li class="${result.breakdown.volume ? 'pass' : 'fail'}">${result.breakdown.volume ? '‚úÖ' : '‚ùå'} Vol ${result.breakdown.volumeRatio.toFixed(2)}x (‚â•1.2x)</li>`);
                    breakdownHTML.push(`<li class="${result.breakdown.rs ? 'pass' : 'fail'}">${result.breakdown.rs ? '‚úÖ' : '‚ùå'} Positive vs SPY</li>`);
                } else {
                    breakdownHTML.push(`<li class="${result.breakdown.rsi ? 'pass' : 'fail'}">${result.breakdown.rsi ? '‚úÖ' : '‚ùå'} RSI ${result.breakdown.rsiValue.toFixed(1)} (‚â•45 & rising)</li>`);
                    breakdownHTML.push(`<li class="${result.breakdown.dma20 ? 'pass' : 'fail'}">${result.breakdown.dma20 ? '‚úÖ' : '‚ùå'} Above 20-DMA</li>`);
                    breakdownHTML.push(`<li class="${result.breakdown.volume ? 'pass' : 'fail'}">${result.breakdown.volume ? '‚úÖ' : '‚ùå'} Vol ${result.breakdown.volumeRatio.toFixed(2)}x (‚â•1.0x)</li>`);
                    breakdownHTML.push(`<li class="${result.breakdown.rs ? 'pass' : 'fail'}">${result.breakdown.rs ? '‚úÖ' : '‚ùå'} Positive vs SPY</li>`);
                }
                
                cardsHTML += `
                    <div class="ticker-card">
                        <div class="ticker-header">
                            <div class="ticker-symbol">${result.ticker}</div>
                            <div class="ticker-meta">
                                <div class="asset-type">${result.assetType} Asset</div>
                                <div class="active-mode ${modeClass}">${result.mode}</div>
                            </div>
                        </div>
                        
                        <div class="score-display">
                            <div class="score-number ${scoreClass}">${result.score}<span style="font-size:1rem; color: var(--text-secondary);">/4</span></div>
                            <div class="score-info">
                                <div class="signal ${signal.class}">${signal.text}</div>
                                <div style="font-size: 0.75rem; color: var(--text-secondary); margin-top: 0.25rem;">${signal.subtext}</div>
                                ${signal.size !== '0%' ? `<div style="font-size: 0.85rem; font-weight: 700; color: var(--accent-blue); margin-top: 0.5rem;">Position: ${signal.size}</div>` : ''}
                            </div>
                        </div>
                        
                        ${perfHTML}
                        
                        <ul class="breakdown">
                            ${breakdownHTML.join('')}
                        </ul>
                    </div>
                `;
            });
            
            cardsHTML += '</div>';
            
            const deploy = results.filter(r => r.score === 4 && r.perf.change5Day <= 5);
            const deploySmall = results.filter(r => r.score === 4 && r.perf.change5Day > 5 && r.perf.change5Day <= 10);
            const tooLate = results.filter(r => r.score === 4 && r.perf.change5Day > 10);
            const watch = results.filter(r => r.score === 2 || r.score === 3);
            const avoid = results.filter(r => r.score <= 1);
            
            const summaryHTML = `
                <div class="summary">
                    <h2>üìã DEPLOYMENT RECOMMENDATIONS</h2>
                    <div class="summary-grid">
                        <div class="summary-section">
                            <h3><span>üü¢</span> DEPLOY NOW (${deploy.length})</h3>
                            <ul>
                                ${deploy.length ? deploy.map(r => `<li>‚Ä¢ ${r.ticker} - 1% position (${r.mode}) ${r.score}/4</li>`).join('') : '<li>None - Fresh Score 4/4 setups only</li>'}
                            </ul>
                        </div>
                        
                        <div class="summary-section">
                            <h3><span>üü°</span> DEPLOY SMALL (${deploySmall.length})</h3>
                            <ul>
                                ${deploySmall.length ? deploySmall.map(r => `<li>‚Ä¢ ${r.ticker} - 0.5-0.75% (extended +${r.perf.change5Day.toFixed(1)}%)</li>`).join('') : '<li>None</li>'}
                            </ul>
                        </div>
                        
                        <div class="summary-section">
                            <h3><span>üî¥</span> TOO LATE (${tooLate.length})</h3>
                            <ul>
                                ${tooLate.length ? tooLate.map(r => `<li>‚Ä¢ ${r.ticker} - Wait for pullback (parabolic +${r.perf.change5Day.toFixed(1)}%)</li>`).join('') : '<li>None</li>'}
                            </ul>
                        </div>
                        
                        <div class="summary-section">
                            <h3><span>‚ö†Ô∏è</span> WATCH (${watch.length})</h3>
                            <ul>
                                ${watch.length ? watch.map(r => `<li>‚Ä¢ ${r.ticker} - ${r.score}/4 - Hold if owned, don't enter new</li>`).join('') : '<li>None</li>'}
                            </ul>
                        </div>
                        
                        <div class="summary-section">
                            <h3><span>üî¥</span> AVOID/EXIT (${avoid.length})</h3>
                            <ul>
                                ${avoid.length ? avoid.map(r => `<li>‚Ä¢ ${r.ticker} (${r.mode}) - ${r.score}/4</li>`).join('') : '<li>None</li>'}
                            </ul>
                        </div>
                    </div>
                    
                    <div style="margin-top: 2rem; padding: 1.5rem; background: var(--bg-secondary); border-radius: 8px; border-left: 4px solid var(--accent-blue);">
                        <h3 style="color: var(--accent-blue); margin-bottom: 1rem; font-size: 1rem;">üìñ DEPLOYMENT RULES</h3>
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 1rem; font-size: 0.85rem;">
                            <div>
                                <div style="font-weight: 700; color: var(--accent-green); margin-bottom: 0.5rem;">üü¢ DEPLOY NOW (1%)</div>
                                <div style="color: var(--text-secondary);">Score 4/4 + 5-day change ‚â§5%<br>Fresh setup, good timing</div>
                            </div>
                            <div>
                                <div style="font-weight: 700; color: var(--accent-yellow); margin-bottom: 0.5rem;">üü° DEPLOY SMALL (0.5-0.75%)</div>
                                <div style="color: var(--text-secondary);">Score 4/4 + 5-day change 5-10%<br>Extended but manageable</div>
                            </div>
                            <div>
                                <div style="font-weight: 700; color: var(--accent-red); margin-bottom: 0.5rem;">üî¥ TOO LATE (0.25% max or WAIT)</div>
                                <div style="color: var(--text-secondary);">Score 4/4 + 5-day change >10%<br>Parabolic, high reversal risk</div>
                            </div>
                            <div>
                                <div style="font-weight: 700; color: var(--accent-yellow); margin-bottom: 0.5rem;">‚ö†Ô∏è WATCH (0%)</div>
                                <div style="color: var(--text-secondary);">Score 2-3 - Don't enter new<br>Hold if already owned</div>
                            </div>
                            <div>
                                <div style="font-weight: 700; color: var(--accent-red); margin-bottom: 0.5rem;">üî¥ EXIT (0%)</div>
                                <div style="color: var(--text-secondary);">Score 0-1 - Trend broken<br>Sell immediately</div>
                            </div>
                        </div>
                    </div>
                </div>
            `;
            
            resultsDiv.innerHTML = stealthHTML + cardsHTML + summaryHTML;
        }

        // Process a single batch
        async function processBatch() {
            if (batchState.currentBatch === 0) {
                updateProgress(0, 2, 'Fetching VOO for regime detection...');
                batchState.vooData = await fetchStockData('VOO');
                await new Promise(resolve => setTimeout(resolve, 8000));
                
                batchState.regimeMode = batchState.vooData ? getRegimeMode(batchState.vooData.prices) : 'RISK';
                
                const regimeModeEl = document.getElementById('regimeMode');
                const regimeTextEl = document.getElementById('regimeText');
                const regimeIconEl = document.getElementById('regimeIcon');
                const vooStatusEl = document.getElementById('vooStatus');
                
                regimeTextEl.textContent = `${batchState.regimeMode} MODE`;
                regimeModeEl.className = `regime-mode ${batchState.regimeMode.toLowerCase()}`;
                regimeIconEl.textContent = batchState.regimeMode === 'RISK' ? 'üìà' : 'üõ°Ô∏è';
                
                if (batchState.vooData) {
                    const currentPrice = batchState.vooData.prices[batchState.vooData.prices.length - 1];
                    const dma200 = calculateMA(batchState.vooData.prices, 200);
                    const pct = ((currentPrice / dma200 - 1) * 100).toFixed(2);
                    vooStatusEl.textContent = `VOO: $${currentPrice.toFixed(2)} vs 200-DMA: $${dma200.toFixed(2)} (${pct > 0 ? '+' : ''}${pct}%)`;
                }
                
                updateProgress(1, 2, 'Fetching SPY for relative strength...');
                batchState.spyData = await fetchStockData('SPY');
                await new Promise(resolve => setTimeout(resolve, 8000));
            }
            
            const startIdx = batchState.currentBatch * batchState.batchSize;
            const endIdx = Math.min(startIdx + batchState.batchSize, batchState.allTickers.length);
            const batchTickers = batchState.allTickers.slice(startIdx, endIdx);
            
            const totalBatches = Math.ceil(batchState.allTickers.length / batchState.batchSize);
            const batchInfo = document.getElementById('batchInfo');
            const batchProgress = document.getElementById('batchProgress');
            
            batchInfo.classList.add('active');
            batchProgress.textContent = `Batch ${batchState.currentBatch + 1} of ${totalBatches}`;
            
            for (let i = 0; i < batchTickers.length; i++) {
                const ticker = batchTickers[i];
                const overallIdx = startIdx + i;
                
                updateProgress(overallIdx + 1, batchState.allTickers.length, 
                    `Fetching ${ticker} (${overallIdx + 1}/${batchState.allTickers.length})...`);
                
                const data = await fetchStockData(ticker);
                
                if (data) {
                    const assetType = assetTypes[ticker] || 'RISK';
                    const mode = getActiveMode(ticker, batchState.regimeMode);
                    const { score, breakdown, perf, perfAnalysis } = calculateScore(ticker, data, batchState.spyData, mode);
                    
                    batchState.results.push({
                        ticker,
                        assetType,
                        mode,
                        score,
                        breakdown,
                        perf,
                        perfAnalysis
                    });
                    
                    renderResults(batchState.results, batchState.regimeMode);
                }
                
                if (i < batchTickers.length - 1) {
                    await new Promise(resolve => setTimeout(resolve, 8000));
                }
            }
            
            batchState.currentBatch++;
            
            if (batchState.currentBatch < totalBatches) {
                const remainingTickers = batchState.allTickers.length - (batchState.currentBatch * batchState.batchSize);
                document.getElementById('progressContainer').classList.remove('active');
                showPauseNotice(batchState.currentBatch, totalBatches, remainingTickers);
            } else {
                finishAnalysis();
            }
        }

        async function runAnalysis() {
            if (Date.now() < nextAvailableTime) {
                alert('Please wait for the countdown timer to finish before running another analysis.');
                return;
            }
            
            const tickersInput = document.getElementById('tickerInput').value;
            const tickers = tickersInput.split(',').map(t => t.trim().toUpperCase()).filter(t => t);
            
            if (tickers.length === 0) {
                alert('Please enter at least one ticker');
                return;
            }
            
            if (batchState.isProcessing) {
                alert('Analysis already in progress. Please wait or click Continue when ready.');
                return;
            }
            
            parseAssetTypes();
            
            batchState = {
                allTickers: tickers,
                currentBatch: 0,
                batchSize: 4,
                results: [],
                regimeMode: null,
                spyData: null,
                vooData: null,
                isProcessing: true
            };
            
            document.getElementById('results').innerHTML = '';
            document.getElementById('pauseNotice').classList.remove('active');
            
            try {
                await processBatch();
            } catch (error) {
                console.error('Analysis error:', error);
                alert('Error running analysis. Check console for details.');
                finishAnalysis();
            }
        }
    </script>
</body>
</html>
